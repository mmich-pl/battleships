package app

import (
	"battleships/internal/battleship_client"
	"battleships/internal/models"
	. "battleships/internal/utils"
	"bufio"
	"context"
	"fmt"
	gui "github.com/grupawp/warships-gui/v2"
	"log"
	"os"
	"strings"
	"time"
)

const (
	InitEndpoint           = "/game"
	GameStatusEndpoint     = "/game"
	BoardEndpoint          = "/game/board"
	OpponentDescription    = "/game/desc"
	FireEndpoint           = "/game/fire"
	WaitingPlayersEndpoint = "/game/list"
	RefreshEndpoint        = "/game/refresh"
	StatsEndpoint          = "/game/stats"
	AbandonEndpoint        = "/game/abandon"
)

type App struct {
	Client             battleship_client.BattleshipClient
	PlayerBoardState   [10][10]gui.State
	OpponentBoardState [10][10]gui.State
	Description        *models.DescriptionResponse
}

func New(c battleship_client.BattleshipClient) *App {
	return &App{
		Client: c,
	}
}

func (a *App) Run() error {
	playerNick := ""
	playerDescription := ""
	if a.Description != nil && a.Description.Nick != "" {
		playerNick = a.Description.Nick
		playerDescription = a.Description.Desc
	} else {
		playerNick, _ = GetPlayerInput("set your nickname or hit enter to get autogenerated one")
		playerDescription, _ = GetPlayerInput("set your description or hit enter to get autogenerated one")
	}

	bot, _ := GetPlayerInput("if you want to play with bot type: y if not leave blank")
	playWithBot := If(strings.ToLower(bot) == "y", true, false)

	playerShipsCoords, _ := GetPlayerInput("set your fleet or leave blank to get autogenerated one\n" +
		"your input should be in format: list of coordinates of ships divided by space. Type your ships in descending order by size")
	playerShipsCoordsList := If(len(playerShipsCoords) == 0, nil, strings.Split(playerShipsCoords, " "))
	enemyNick := ""

	if !playWithBot {
		enemyNick, _ = GetPlayerInput("type enemy nick or leave blank to wait for other players request")
	}

	err := a.Client.InitGame(InitEndpoint, playerNick, playerDescription, enemyNick, playerShipsCoordsList, playWithBot)
	if err != nil {
		return fmt.Errorf("failed to init game: %w", err)
	}

	ctx, cancel := context.WithCancel(context.Background())
	fmt.Println("the game has been initiated, waiting for opponent")
	go func(ctx context.Context) {
		for {
			time.Sleep(10 * time.Second)
			select {
			case <-ctx.Done():
				return
			default:
				_ = a.Client.RefreshSession(RefreshEndpoint)
			}
		}
	}(ctx)

	status, err := a.setUpGame(cancel)
	if err != nil {
		return err
	}

	bd := InitBoardData(a)

	bd.RenderBoards(status)
	return nil
}

func (a *App) setUpGame(cancel context.CancelFunc) (*models.StatusResponse, error) {
	status, err := a.waitForGameStart(cancel)
	if err != nil {
		return nil, fmt.Errorf("failed to get game status: %w", err)
	}

	log.Print(status)
	a.Description, err = a.Client.Description(OpponentDescription)
	if err != nil {
		return nil, fmt.Errorf("failed to get game status: %w", err)
	}

	board, err := a.Client.Board(BoardEndpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to get board: %w", err)
	}

	if err = a.setUpBoardsState(board); err != nil {
		return nil, err
	}

	return status, nil
}

func GetPlayerInput(mess string) (string, error) {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println(mess)

	input, err := reader.ReadString('\n')
	if err != nil {
		log.Println("something went wrong, try again. cause: %w", err)
	}
	input = strings.TrimSpace(input)
	if input == "quit" {
		return "", fmt.Errorf("user quit")
	}
	return input, nil
}

func (a *App) waitForGameStart(cancel context.CancelFunc) (*models.StatusResponse, error) {
	status, err := a.Client.GameStatus(GameStatusEndpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to get game status: %w", err)
	}

	type channelResponse struct {
		*models.StatusResponse
		error
	}

	ticker := time.NewTicker(time.Second)
	channel := make(chan channelResponse, 1)

	go func() {
		for range ticker.C {
			if status.GameStatus == "game_in_progress" {
				log.Println("connection was established")
				channel <- channelResponse{status, nil}
				cancel()
				break
			}

			status, err = a.Client.GameStatus(GameStatusEndpoint)
			if err != nil {
				cancel()
				channel <- channelResponse{nil, err}
			}
		}
	}()

	resp := <-channel
	return resp.StatusResponse, resp.error
}
