package app

import (
	"battleships/internal/app/menu"
	"battleships/internal/battleship_client"
	"battleships/internal/models"
	. "battleships/internal/utils"
	"context"
	"fmt"
	gui "github.com/grupawp/warships-gui/v2"
	"strings"
	"time"
)

type App struct {
	Client             battleship_client.BattleshipClient
	PlayerBoardState   [10][10]gui.State
	OpponentBoardState [10][10]gui.State
	Description        *models.DescriptionResponse
}

func New(c battleship_client.BattleshipClient) *App {
	return &App{
		Client: c,
	}
}

func (a *App) Run() error {
	playerNick, playerDescription, playerShipsCoordsList, playWithBot, enemyNick, err2 := a.getPlayerData()
	if err2 != nil {
		return err2
	}
	err := a.Client.InitGame(playerNick, playerDescription, enemyNick, playerShipsCoordsList, playWithBot)
	if err != nil {
		return fmt.Errorf("failed to init game: %w", err)
	}

	ctx := context.Background()
	fmt.Println("the game has been initiated, waiting for opponent")
	go func(ctx context.Context) {
		for {
			time.Sleep(10 * time.Second)
			select {
			case <-ctx.Done():
				return
			default:
				_ = a.Client.RefreshSession()
			}
		}
	}(ctx)

	status, err := a.setUpGame()
	if err != nil {
		return err
	}

	bd := InitBoardData(a)

	err = bd.RenderGameBoards(status)
	if err != nil {
		return err
	}
	return nil
}

func (a *App) getPlayerData() (string, string, []string, bool, string, error) {
	if a.Client.GetToken() != "" {
		a.Client.ResetToken()
	}
	// Player nick and description setup
	var playerNick string
	var playerDescription string

	if a.Description != nil && a.Description.Nick != "" {
		playerNick = a.Description.Nick
		playerDescription = a.Description.Desc
	} else {
		nickIsValid := false
		for !nickIsValid {
			playerNick, _ = GetPlayerInput("set your nickname or hit enter to get autogenerated one: ")
			nickLen := len(playerNick)
			if nickLen == 0 {
				nickIsValid = true
			} else if nickLen < 2 || nickLen > 20 {
				nickIsValid = false
			} else {
				nickIsValid = true
			}
		}
		playerDescription, _ = GetPlayerInput("set your description or hit enter to get autogenerated one: ")
	}

	// Player fleet setup
	fleet := GetConditionalPlayerInput([]string{"y", "n"}, "do you want to set your own fleet? [y/n]: ")
	ownFleet := If(strings.ToLower(fleet) == "y", true, false)
	var playerShips []string
	if ownFleet {
		playerShips = RenderInputBoard()
	}
	playerShipsCoordsList := If(len(playerShips) != 0, playerShips, nil)

	// Player opponent setup
	bot := GetConditionalPlayerInput([]string{"y", "n"}, "do you want to play with bot? [y/n]: ")
	playWithBot := If(strings.ToLower(bot) == "y", true, false)
	enemyNick := ""
	if !playWithBot {
		fmt.Println("Type player name from list:")
		playerList, err := a.Client.GetPlayersList()
		if err != nil {
			return "", "", nil, false, "", err
		}

		var nicks []string
		for _, data := range *playerList {
			fmt.Println(data.GameStatus, " | ", data.Nick)
			nicks = append(nicks, data.Nick)
		}
		fmt.Println()

		if err != nil {
			return "", "", nil, false, "", err
		}
		enemyNick = menu.Select(nicks, "type enemy nick or leave blank to wait for other players request: ")
	}
	return playerNick, playerDescription, playerShipsCoordsList, playWithBot, enemyNick, nil
}

func (a *App) setUpGame() (*models.StatusResponse, error) {
	status, err := a.waitForGameStart()
	if err != nil {
		return nil, err
	}

	a.Description, err = a.Client.Description()
	if err != nil {
		return nil, fmt.Errorf("failed to get game status: %w", err)
	}

	board, err := a.Client.Board()
	if err != nil {
		return nil, fmt.Errorf("failed to get board: %w", err)
	}

	if err = a.setUpBoardsState(board); err != nil {
		return nil, err
	}

	return status, nil
}

func (a *App) waitForGameStart() (*models.StatusResponse, error) {
	ctx, cancel := context.WithTimeout(context.Background(), time.Minute)
	defer cancel()

	type channelResponse struct {
		*models.StatusResponse
		error
	}

	// This function checks the game status and sends the result to the given channel.
	checkGameStatus := func(ctx context.Context, resultCh chan<- channelResponse) {
		status, err := a.Client.GameStatus()
		if err != nil {
			resultCh <- channelResponse{nil, fmt.Errorf("failed to get game status: %w", err)}
		} else if status.GameStatus == "game_in_progress" {
			resultCh <- channelResponse{status, nil}
		}
	}

	resultCh := make(chan channelResponse, 1)
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return nil, fmt.Errorf("waitForGameStart timed out")
		case <-ticker.C:
			go checkGameStatus(ctx, resultCh)
		case resp := <-resultCh:
			if resp.StatusResponse != nil && resp.error == nil {
				return resp.StatusResponse, nil
			}
			return nil, resp.error
		}
	}
}
